"""CVE-to-Exploit Pipeline orchestration.

Main pipeline that coordinates CVE lookup, exploit search,
and LLM synthesis.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional


class ExploitSource(str, Enum):
    """Source of exploit information."""
    
    NVD = "nvd"               # National Vulnerability Database
    EXPLOIT_DB = "exploit_db" # Exploit-DB
    GITHUB = "github"         # GitHub PoC repositories
    NUCLEI = "nuclei"         # Nuclei templates
    LLM = "llm"               # LLM-synthesized


@dataclass
class ExploitResult:
    """Result from exploit pipeline.
    
    Contains exploit code and metadata from various sources.
    """
    
    cve_id: str
    source: ExploitSource
    title: str
    description: str = ""
    code: str = ""
    url: str = ""
    confidence: float = 0.0   # 0.0 to 1.0
    verified: bool = False
    safe_for_testing: bool = False
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    metadata: dict = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "cve_id": self.cve_id,
            "source": self.source.value,
            "title": self.title,
            "description": self.description,
            "code": self.code,
            "url": self.url,
            "confidence": self.confidence,
            "verified": self.verified,
            "safe_for_testing": self.safe_for_testing,
            "timestamp": self.timestamp,
            "metadata": self.metadata,
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> "ExploitResult":
        """Create from dictionary."""
        return cls(
            cve_id=data.get("cve_id", ""),
            source=ExploitSource(data.get("source", "llm")),
            title=data.get("title", ""),
            description=data.get("description", ""),
            code=data.get("code", ""),
            url=data.get("url", ""),
            confidence=data.get("confidence", 0.0),
            verified=data.get("verified", False),
            safe_for_testing=data.get("safe_for_testing", False),
            timestamp=data.get("timestamp", ""),
            metadata=data.get("metadata", {}),
        )
    
    def format(self) -> str:
        """Format result for display.
        
        Returns:
            Formatted result string.
        """
        verified_str = "âœ… Verified" if self.verified else "âš ï¸ Unverified"
        safe_str = "ðŸ”’ Safe" if self.safe_for_testing else "âš ï¸ Unsafe"
        return f"""
[{self.source.value.upper()}] {self.title}
CVE: {self.cve_id}
Status: {verified_str} | {safe_str}
Confidence: {self.confidence:.0%}
URL: {self.url}
---
{self.description}
""".strip()


class ExploitPipeline:
    """CVE-to-Exploit pipeline orchestrator.
    
    Coordinates lookups from NVD, Exploit-DB, GitHub, and LLM synthesis
    to find or generate exploit code for known CVEs.
    
    Example:
        pipeline = ExploitPipeline()
        results = await pipeline.search("CVE-2024-1234")
    """
    
    def __init__(
        self,
        nvd_api_key: Optional[str] = None,
        github_token: Optional[str] = None,
        enable_llm_synthesis: bool = True,
        safety_check: bool = True,
    ):
        """Initialize the pipeline.
        
        Args:
            nvd_api_key: Optional NVD API key for higher rate limits.
            github_token: Optional GitHub token.
            enable_llm_synthesis: Whether to use LLM for exploit synthesis.
            safety_check: Whether to perform safety checks on exploits.
        """
        # Import here to avoid circular imports
        from .cve import CVELookup
        from .exploitdb import ExploitDBSearch
        from .github import GitHubSearch
        
        self._cve_lookup = CVELookup(api_key=nvd_api_key)
        self._exploitdb = ExploitDBSearch()
        self._github = GitHubSearch(token=github_token)
        self._enable_llm = enable_llm_synthesis
        self._safety_check = safety_check
        self._cache: dict[str, list[ExploitResult]] = {}
    
    async def search(
        self,
        cve_id: str,
        sources: Optional[list[ExploitSource]] = None,
    ) -> list[ExploitResult]:
        """Search for exploits related to a CVE.
        
        Args:
            cve_id: CVE identifier.
            sources: Optional list of sources to search.
                    Defaults to all sources.
        
        Returns:
            List of exploit results sorted by confidence.
        """
        cve_id = cve_id.upper().strip()
        
        # Validate CVE format
        from .cve import validate_cve_id
        if not validate_cve_id(cve_id):
            return []
        
        # Check cache
        cache_key = f"{cve_id}:{sources}"
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        # Default to all sources
        if sources is None:
            sources = [
                ExploitSource.NVD,
                ExploitSource.EXPLOIT_DB,
                ExploitSource.GITHUB,
            ]
            if self._enable_llm:
                sources.append(ExploitSource.LLM)
        
        results: list[ExploitResult] = []
        
        # Search each source
        for source in sources:
            source_results = await self._search_source(cve_id, source)
            results.extend(source_results)
        
        # Sort by confidence
        results.sort(key=lambda x: x.confidence, reverse=True)
        
        # Apply safety checks
        if self._safety_check:
            results = await self._apply_safety_checks(results)
        
        self._cache[cache_key] = results
        return results
    
    async def _search_source(
        self,
        cve_id: str,
        source: ExploitSource,
    ) -> list[ExploitResult]:
        """Search a specific source for exploits.
        
        Args:
            cve_id: CVE identifier.
            source: Source to search.
            
        Returns:
            List of results from that source.
        """
        results: list[ExploitResult] = []
        
        if source == ExploitSource.NVD:
            results = await self._search_nvd(cve_id)
        elif source == ExploitSource.EXPLOIT_DB:
            results = await self._search_exploitdb(cve_id)
        elif source == ExploitSource.GITHUB:
            results = await self._search_github(cve_id)
        elif source == ExploitSource.LLM:
            results = await self._synthesize_llm(cve_id)
        
        return results
    
    async def _search_nvd(self, cve_id: str) -> list[ExploitResult]:
        """Search NVD for CVE information.
        
        Args:
            cve_id: CVE identifier.
            
        Returns:
            Exploit results with references.
        """
        cve_info = await self._cve_lookup.get(cve_id)
        if not cve_info:
            return []
        
        results: list[ExploitResult] = []
        
        # Extract exploit references
        for ref in cve_info.references:
            if ref.is_exploit or ref.is_poc:
                results.append(ExploitResult(
                    cve_id=cve_id,
                    source=ExploitSource.NVD,
                    title=f"NVD Reference: {ref.source}",
                    description=cve_info.description,
                    url=ref.url,
                    confidence=0.7,
                    verified=True,
                    metadata={
                        "cvss": cve_info.cvss.to_dict() if cve_info.cvss else None,
                        "cwe_ids": cve_info.cwe_ids,
                    },
                ))
        
        # If no exploit references, still return CVE info
        if not results:
            results.append(ExploitResult(
                cve_id=cve_id,
                source=ExploitSource.NVD,
                title=f"CVE Info: {cve_id}",
                description=cve_info.description,
                url=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                confidence=0.3,
                verified=True,
                metadata={
                    "cvss": cve_info.cvss.to_dict() if cve_info.cvss else None,
                    "cwe_ids": cve_info.cwe_ids,
                },
            ))
        
        return results
    
    async def _search_exploitdb(self, cve_id: str) -> list[ExploitResult]:
        """Search Exploit-DB for exploits.
        
        Args:
            cve_id: CVE identifier.
            
        Returns:
            Exploit results.
        """
        edb_results = await self._exploitdb.search_by_cve(cve_id)
        
        results: list[ExploitResult] = []
        for edb in edb_results:
            # Download exploit code
            code = await self._exploitdb.get_exploit_code(edb.edb_id)
            
            results.append(ExploitResult(
                cve_id=cve_id,
                source=ExploitSource.EXPLOIT_DB,
                title=edb.title,
                description=f"Exploit-DB: EDB-{edb.edb_id}",
                code=code,
                url=edb.url,
                confidence=0.9 if edb.verified else 0.6,
                verified=edb.verified,
                metadata={
                    "edb_id": edb.edb_id,
                    "author": edb.author,
                    "platform": edb.platform.value if edb.platform else None,
                    "exploit_type": edb.exploit_type.value if edb.exploit_type else None,
                },
            ))
        
        return results
    
    async def _search_github(self, cve_id: str) -> list[ExploitResult]:
        """Search GitHub for PoCs.
        
        Args:
            cve_id: CVE identifier.
            
        Returns:
            Exploit results.
        """
        pocs = await self._github.search_by_cve(cve_id)
        
        results: list[ExploitResult] = []
        for poc in pocs:
            # Try to get exploit code
            files = await self._github.get_repo_files(poc)
            code = ""
            for f in files:
                if f.endswith(".py") or "exploit" in f.lower():
                    code = await self._github.get_file_content(poc, f)
                    break
            
            # Map quality to confidence
            from .github import PoCQuality
            quality_confidence = {
                PoCQuality.HIGH: 0.8,
                PoCQuality.MEDIUM: 0.6,
                PoCQuality.LOW: 0.4,
                PoCQuality.UNKNOWN: 0.3,
            }
            
            results.append(ExploitResult(
                cve_id=cve_id,
                source=ExploitSource.GITHUB,
                title=f"{poc.owner}/{poc.repo_name}",
                description=poc.description,
                code=code,
                url=poc.url,
                confidence=quality_confidence.get(poc.quality, 0.3),
                verified=poc.stars >= 50,
                metadata={
                    "stars": poc.stars,
                    "forks": poc.forks,
                    "language": poc.language,
                    "quality": poc.quality.value,
                },
            ))
        
        return results
    
    async def _synthesize_llm(self, cve_id: str) -> list[ExploitResult]:
        """Synthesize exploit using LLM.
        
        Uses CVE information to generate exploit code via LLM.
        
        Args:
            cve_id: CVE identifier.
            
        Returns:
            LLM-generated exploit results.
        """
        # Get CVE info for context
        cve_info = await self._cve_lookup.get(cve_id)
        if not cve_info:
            return []
        
        # In production: call LLM to generate exploit
        # For testing: return placeholder
        code = f"""#!/usr/bin/env python3
# LLM-synthesized exploit for {cve_id}
# Based on: {cve_info.description[:100]}...
#
# WARNING: This is AI-generated code. Use with caution.

import sys
import requests

def check_vulnerability(target):
    \"\"\"Check if target is vulnerable.\"\"\"
    # Implementation would be based on CVE details
    print(f"Checking {{target}} for {cve_id}...")
    return True

def exploit(target):
    \"\"\"Attempt exploitation.\"\"\"
    if check_vulnerability(target):
        print(f"Target {{target}} appears vulnerable to {cve_id}")
        # Exploit logic here
        pass

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: exploit.py <target>")
        sys.exit(1)
    exploit(sys.argv[1])
"""
        
        return [ExploitResult(
            cve_id=cve_id,
            source=ExploitSource.LLM,
            title=f"LLM-Synthesized Exploit for {cve_id}",
            description=f"AI-generated based on: {cve_info.description}",
            code=code,
            confidence=0.4,  # Lower confidence for generated code
            verified=False,
            safe_for_testing=False,  # Requires manual review
            metadata={
                "cvss": cve_info.cvss.to_dict() if cve_info.cvss else None,
                "cwe_ids": cve_info.cwe_ids,
                "generated": True,
            },
        )]
    
    async def _apply_safety_checks(
        self,
        results: list[ExploitResult],
    ) -> list[ExploitResult]:
        """Apply safety checks to exploit results.
        
        Marks exploits as safe/unsafe for testing.
        
        Args:
            results: List of exploit results.
            
        Returns:
            Results with safety flags set.
        """
        for result in results:
            result.safe_for_testing = self._is_safe_for_testing(result)
        
        return results
    
    def _is_safe_for_testing(self, result: ExploitResult) -> bool:
        """Determine if exploit is safe for testing.
        
        Args:
            result: Exploit result to check.
            
        Returns:
            True if safe for testing in controlled environment.
        """
        # Check for dangerous patterns in code
        dangerous_patterns = [
            "rm -rf /",
            "format c:",
            ":(){ :|:& };:",  # Fork bomb
            "dd if=/dev/zero",
            "mkfs.",
        ]
        
        code_lower = result.code.lower()
        for pattern in dangerous_patterns:
            if pattern in code_lower:
                return False
        
        # Verified exploits from trusted sources are safer
        if result.verified and result.source in (
            ExploitSource.EXPLOIT_DB,
            ExploitSource.NVD,
        ):
            return True
        
        # GitHub PoCs with high quality are safer
        if result.source == ExploitSource.GITHUB:
            quality = result.metadata.get("quality", "unknown")
            if quality in ("high", "medium"):
                return True
        
        # LLM-generated requires manual review
        if result.source == ExploitSource.LLM:
            return False
        
        return False
    
    async def get_exploit_code(
        self,
        cve_id: str,
        prefer_source: Optional[ExploitSource] = None,
    ) -> Optional[str]:
        """Get exploit code for a CVE.
        
        Searches all sources and returns the best exploit code.
        
        Args:
            cve_id: CVE identifier.
            prefer_source: Optional preferred source.
            
        Returns:
            Exploit code or None if not found.
        """
        results = await self.search(cve_id)
        
        # Filter by preferred source if specified
        if prefer_source:
            preferred = [r for r in results if r.source == prefer_source]
            if preferred:
                results = preferred
        
        # Return first result with code
        for result in results:
            if result.code:
                return result.code
        
        return None
    
    def clear_cache(self) -> None:
        """Clear all caches."""
        self._cache.clear()
        self._cve_lookup.clear_cache()
        self._exploitdb.clear_cache()
        self._github.clear_cache()
