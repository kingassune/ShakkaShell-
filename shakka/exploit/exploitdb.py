"""Exploit-DB integration for CVE-to-Exploit pipeline.

Provides search capabilities against Exploit-DB database.
Uses web API and local searchsploit when available.
"""

import asyncio
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional

import httpx


class ExploitType(str, Enum):
    """Types of exploits in Exploit-DB."""
    
    WEBAPPS = "webapps"
    REMOTE = "remote"
    LOCAL = "local"
    DOS = "dos"
    SHELLCODE = "shellcode"
    PAPERS = "papers"


class Platform(str, Enum):
    """Target platforms for exploits."""
    
    LINUX = "linux"
    WINDOWS = "windows"
    MULTIPLE = "multiple"
    PHP = "php"
    PYTHON = "python"
    UNIX = "unix"
    HARDWARE = "hardware"
    OSX = "osx"
    ANDROID = "android"
    IOS = "ios"


@dataclass
class ExploitDBResult:
    """A single result from Exploit-DB search.
    
    Contains exploit metadata and download information.
    """
    
    edb_id: str
    title: str
    cve_id: Optional[str] = None
    exploit_type: Optional[ExploitType] = None
    platform: Optional[Platform] = None
    author: str = ""
    date_published: str = ""
    verified: bool = False
    url: str = ""
    download_url: str = ""
    
    def __post_init__(self):
        """Generate URLs if not provided."""
        if not self.url:
            self.url = f"https://www.exploit-db.com/exploits/{self.edb_id}"
        if not self.download_url:
            self.download_url = f"https://www.exploit-db.com/download/{self.edb_id}"
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "edb_id": self.edb_id,
            "title": self.title,
            "cve_id": self.cve_id,
            "exploit_type": self.exploit_type.value if self.exploit_type else None,
            "platform": self.platform.value if self.platform else None,
            "author": self.author,
            "date_published": self.date_published,
            "verified": self.verified,
            "url": self.url,
            "download_url": self.download_url,
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> "ExploitDBResult":
        """Create from dictionary."""
        return cls(
            edb_id=data.get("edb_id", ""),
            title=data.get("title", ""),
            cve_id=data.get("cve_id"),
            exploit_type=ExploitType(data["exploit_type"]) if data.get("exploit_type") else None,
            platform=Platform(data["platform"]) if data.get("platform") else None,
            author=data.get("author", ""),
            date_published=data.get("date_published", ""),
            verified=data.get("verified", False),
        )
    
    def format(self) -> str:
        """Format result for display.
        
        Returns:
            Formatted result string.
        """
        verified_icon = "✅" if self.verified else "❓"
        return f"[EDB-{self.edb_id}] {verified_icon} {self.title}"


class ExploitDBSearch:
    """Exploit-DB search service.
    
    Provides methods to search for exploits by CVE ID or keywords.
    
    Example:
        search = ExploitDBSearch()
        results = await search.search_by_cve("CVE-2024-1234")
    """
    
    SEARCHSPLOIT_API = "https://www.exploit-db.com/search"
    
    def __init__(self):
        """Initialize the search service."""
        self._cache: dict[str, list[ExploitDBResult]] = {}
    
    async def search_by_cve(self, cve_id: str) -> list[ExploitDBResult]:
        """Search for exploits by CVE ID.
        
        Args:
            cve_id: CVE identifier to search.
            
        Returns:
            List of matching exploits.
        """
        cve_id = cve_id.upper().strip()
        
        # Check cache
        if cve_id in self._cache:
            return self._cache[cve_id]
        
        # In production, this would use the Exploit-DB API or searchsploit
        results = await self._search(cve_id)
        
        self._cache[cve_id] = results
        return results
    
    async def search_by_keyword(
        self,
        keyword: str,
        exploit_type: Optional[ExploitType] = None,
        platform: Optional[Platform] = None,
    ) -> list[ExploitDBResult]:
        """Search for exploits by keyword.
        
        Args:
            keyword: Search term.
            exploit_type: Optional filter by exploit type.
            platform: Optional filter by platform.
            
        Returns:
            List of matching exploits.
        """
        cache_key = f"{keyword}:{exploit_type}:{platform}"
        
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        results = await self._search(keyword, exploit_type, platform)
        
        self._cache[cache_key] = results
        return results
    
    async def _search(
        self,
        query: str,
        exploit_type: Optional[ExploitType] = None,
        platform: Optional[Platform] = None,
    ) -> list[ExploitDBResult]:
        """Perform search against Exploit-DB.
        
        Uses searchsploit CLI if available, otherwise falls back to web API.
        
        Args:
            query: Search query.
            exploit_type: Optional exploit type filter.
            platform: Optional platform filter.
            
        Returns:
            Search results.
        """
        # Try searchsploit first (local, faster)
        results = await self._search_with_searchsploit(query)
        if results:
            return self._filter_results(results, exploit_type, platform)
        
        # Fallback to web search
        results = await self._search_web(query)
        return self._filter_results(results, exploit_type, platform)
    
    async def _search_with_searchsploit(self, query: str) -> list[ExploitDBResult]:
        """Search using local searchsploit CLI.
        
        Args:
            query: Search query.
            
        Returns:
            List of results or empty if searchsploit not available.
        """
        try:
            # Run searchsploit with JSON output
            proc = await asyncio.create_subprocess_exec(
                "searchsploit", "-j", query,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, _ = await asyncio.wait_for(proc.communicate(), timeout=30)
            
            if proc.returncode != 0:
                return []
            
            import json
            data = json.loads(stdout.decode())
            
            results = []
            for item in data.get("RESULTS_EXPLOIT", []):
                # Parse searchsploit output
                result = ExploitDBResult(
                    edb_id=item.get("EDB-ID", ""),
                    title=item.get("Title", ""),
                    date_published=item.get("Date", ""),
                    author=item.get("Author", ""),
                    platform=self._parse_platform(item.get("Platform", "")),
                    exploit_type=self._parse_type(item.get("Type", "")),
                    verified=item.get("Verified", "") == "1",
                )
                results.append(result)
            
            return results
        except (FileNotFoundError, asyncio.TimeoutError, Exception):
            # searchsploit not available
            return []
    
    async def _search_web(self, query: str) -> list[ExploitDBResult]:
        """Search Exploit-DB via web (scraping fallback).
        
        Args:
            query: Search query.
            
        Returns:
            List of results.
        """
        # Use exploit-db.com search
        url = "https://www.exploit-db.com/search"
        params = {"q": query}
        headers = {
            "User-Agent": "ShakkaShell/2.0 (Security Research Tool)",
            "Accept": "application/json",
            "X-Requested-With": "XMLHttpRequest",
        }
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(url, params=params, headers=headers)
                response.raise_for_status()
                data = response.json()
                
                results = []
                for item in data.get("data", []):
                    result = ExploitDBResult(
                        edb_id=str(item.get("id", "")),
                        title=item.get("description", [""])[0] if isinstance(item.get("description"), list) else item.get("description", ""),
                        cve_id=item.get("codes", [{}])[0].get("code_id") if item.get("codes") else None,
                        date_published=item.get("date_published", ""),
                        author=item.get("author", {}).get("name", "") if isinstance(item.get("author"), dict) else "",
                        verified=item.get("verified") == "1",
                    )
                    results.append(result)
                
                return results
        except (httpx.HTTPStatusError, httpx.RequestError, Exception):
            return []
    
    def _filter_results(
        self,
        results: list[ExploitDBResult],
        exploit_type: Optional[ExploitType],
        platform: Optional[Platform],
    ) -> list[ExploitDBResult]:
        """Filter results by type and platform."""
        filtered = []
        for result in results:
            if exploit_type and result.exploit_type != exploit_type:
                continue
            if platform and result.platform != platform:
                continue
            filtered.append(result)
        return filtered if filtered else results  # Return all if none match filters
    
    def _parse_platform(self, platform_str: str) -> Optional[Platform]:
        """Parse platform string to enum."""
        platform_map = {
            "linux": Platform.LINUX,
            "windows": Platform.WINDOWS,
            "multiple": Platform.MULTIPLE,
            "php": Platform.PHP,
            "python": Platform.PYTHON,
            "unix": Platform.UNIX,
            "hardware": Platform.HARDWARE,
            "osx": Platform.OSX,
            "android": Platform.ANDROID,
            "ios": Platform.IOS,
        }
        return platform_map.get(platform_str.lower())
    
    def _parse_type(self, type_str: str) -> Optional[ExploitType]:
        """Parse exploit type string to enum."""
        type_map = {
            "webapps": ExploitType.WEBAPPS,
            "remote": ExploitType.REMOTE,
            "local": ExploitType.LOCAL,
            "dos": ExploitType.DOS,
            "shellcode": ExploitType.SHELLCODE,
            "papers": ExploitType.PAPERS,
        }
        return type_map.get(type_str.lower())
    
    async def get_exploit_code(self, edb_id: str) -> str:
        """Download exploit code from Exploit-DB.
        
        Args:
            edb_id: Exploit-DB ID.
            
        Returns:
            Exploit source code.
        """
        # Try to download from Exploit-DB
        url = f"https://www.exploit-db.com/raw/{edb_id}"
        headers = {
            "User-Agent": "ShakkaShell/2.0 (Security Research Tool)",
        }
        
        try:
            async with httpx.AsyncClient(timeout=30.0, follow_redirects=True) as client:
                response = await client.get(url, headers=headers)
                response.raise_for_status()
                return response.text
        except (httpx.HTTPStatusError, httpx.RequestError, Exception) as e:
            return f"# Unable to fetch exploit {edb_id}: {str(e)}"
    
    def clear_cache(self) -> None:
        """Clear search cache."""
        self._cache.clear()
