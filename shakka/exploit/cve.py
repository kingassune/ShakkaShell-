"""CVE information lookup and parsing.

Provides integration with NIST NVD API for vulnerability details.
"""

import re
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional

import httpx


class CVSSSeverity(str, Enum):
    """CVSS severity levels."""
    
    NONE = "none"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"
    
    @classmethod
    def from_score(cls, score: float) -> "CVSSSeverity":
        """Get severity from CVSS score.
        
        Args:
            score: CVSS score (0.0-10.0).
            
        Returns:
            Corresponding severity level.
        """
        if score == 0.0:
            return cls.NONE
        elif score < 4.0:
            return cls.LOW
        elif score < 7.0:
            return cls.MEDIUM
        elif score < 9.0:
            return cls.HIGH
        else:
            return cls.CRITICAL


@dataclass
class CVSSScore:
    """CVSS score information."""
    
    version: str = "3.1"
    score: float = 0.0
    vector: str = ""
    severity: CVSSSeverity = CVSSSeverity.NONE
    
    @classmethod
    def from_nvd(cls, cvss_data: dict) -> "CVSSScore":
        """Create from NVD CVSS data.
        
        Args:
            cvss_data: CVSS data from NVD API.
            
        Returns:
            CVSSScore instance.
        """
        score = cvss_data.get("baseScore", 0.0)
        return cls(
            version=cvss_data.get("version", "3.1"),
            score=score,
            vector=cvss_data.get("vectorString", ""),
            severity=CVSSSeverity.from_score(score),
        )
    
    def to_dict(self) -> dict:
        """Convert to dictionary.
        
        Returns:
            Dictionary representation.
        """
        return {
            "version": self.version,
            "score": self.score,
            "vector": self.vector,
            "severity": self.severity.value,
        }
    
    def format(self) -> str:
        """Format score for display.
        
        Returns:
            Formatted score string.
        """
        severity_colors = {
            CVSSSeverity.NONE: "âšª",
            CVSSSeverity.LOW: "ðŸŸ¢",
            CVSSSeverity.MEDIUM: "ðŸŸ¡",
            CVSSSeverity.HIGH: "ðŸŸ ",
            CVSSSeverity.CRITICAL: "ðŸ”´",
        }
        icon = severity_colors.get(self.severity, "â“")
        return f"{icon} {self.score} ({self.severity.value.title()})"


@dataclass
class CVEReference:
    """A reference link for a CVE."""
    
    url: str
    source: str = ""
    tags: list[str] = field(default_factory=list)
    
    @property
    def is_exploit(self) -> bool:
        """Check if reference is an exploit link."""
        return "Exploit" in self.tags or "exploit-db" in self.url.lower()
    
    @property
    def is_poc(self) -> bool:
        """Check if reference is a PoC."""
        return "github.com" in self.url.lower() and any(
            term in self.url.lower() for term in ["poc", "exploit", "cve-"]
        )


@dataclass
class CVEInfo:
    """Complete CVE information.
    
    Contains vulnerability details from NVD including description,
    CVSS score, affected products, and references.
    """
    
    cve_id: str
    description: str = ""
    cvss: Optional[CVSSScore] = None
    published: Optional[str] = None
    modified: Optional[str] = None
    references: list[CVEReference] = field(default_factory=list)
    affected_products: list[str] = field(default_factory=list)
    cwe_ids: list[str] = field(default_factory=list)
    
    @property
    def is_valid(self) -> bool:
        """Check if CVE has valid data."""
        return bool(self.description)
    
    @property
    def exploit_references(self) -> list[CVEReference]:
        """Get references tagged as exploits."""
        return [ref for ref in self.references if ref.is_exploit]
    
    @property
    def poc_references(self) -> list[CVEReference]:
        """Get references that appear to be PoCs."""
        return [ref for ref in self.references if ref.is_poc]
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "cve_id": self.cve_id,
            "description": self.description,
            "cvss": {
                "version": self.cvss.version,
                "score": self.cvss.score,
                "vector": self.cvss.vector,
                "severity": self.cvss.severity.value,
            } if self.cvss else None,
            "published": self.published,
            "modified": self.modified,
            "references": [{"url": r.url, "source": r.source, "tags": r.tags} for r in self.references],
            "affected_products": self.affected_products,
            "cwe_ids": self.cwe_ids,
        }
    
    def format_summary(self) -> str:
        """Format CVE summary for display.
        
        Returns:
            Formatted summary string.
        """
        lines = [
            f"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—",
            f"â•‘  {self.cve_id}",
        ]
        
        if self.cvss:
            lines.append(f"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
            lines.append(f"â•‘  CVSS: {self.cvss.format()}")
        
        if self.description:
            lines.append(f"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
            # Truncate description
            desc = self.description[:100] + "..." if len(self.description) > 100 else self.description
            lines.append(f"â•‘  {desc}")
        
        if self.affected_products:
            lines.append(f"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
            lines.append(f"â•‘  Affected: {', '.join(self.affected_products[:3])}")
        
        lines.append(f"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        
        return "\n".join(lines)


# CVE ID pattern
CVE_PATTERN = re.compile(r"^CVE-\d{4}-\d{4,}$", re.IGNORECASE)


def validate_cve_id(cve_id: str) -> bool:
    """Validate CVE ID format.
    
    Args:
        cve_id: CVE identifier to validate.
        
    Returns:
        True if valid format.
    """
    return bool(CVE_PATTERN.match(cve_id))


def normalize_cve_id(cve_id: str) -> str:
    """Normalize CVE ID to uppercase format.
    
    Args:
        cve_id: CVE identifier.
        
    Returns:
        Normalized CVE ID (uppercase).
    """
    return cve_id.upper().strip()


class CVELookup:
    """CVE information lookup service.
    
    Provides methods to fetch CVE details from NVD API.
    
    Example:
        lookup = CVELookup()
        info = await lookup.get("CVE-2024-1234")
    """
    
    NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    
    def __init__(self, api_key: Optional[str] = None):
        """Initialize the lookup service.
        
        Args:
            api_key: Optional NVD API key for higher rate limits.
        """
        self.api_key = api_key
        self._cache: dict[str, CVEInfo] = {}
    
    async def get(self, cve_id: str) -> CVEInfo:
        """Get CVE information.
        
        Args:
            cve_id: CVE identifier.
            
        Returns:
            CVEInfo with vulnerability details.
            
        Raises:
            ValueError: If CVE ID format is invalid.
        """
        cve_id = normalize_cve_id(cve_id)
        
        if not validate_cve_id(cve_id):
            raise ValueError(f"Invalid CVE ID format: {cve_id}")
        
        # Check cache
        if cve_id in self._cache:
            return self._cache[cve_id]
        
        # In production, this would make an HTTP request to NVD API
        # For now, return a simulated response
        info = await self._fetch_from_nvd(cve_id)
        
        self._cache[cve_id] = info
        return info
    
    async def _fetch_from_nvd(self, cve_id: str) -> CVEInfo:
        """Fetch CVE from NVD API.
        
        Makes actual HTTP request to NVD API 2.0.
        
        Args:
            cve_id: CVE identifier.
            
        Returns:
            CVEInfo from NVD.
        """
        # Build request headers
        headers = {
            "User-Agent": "ShakkaShell/2.0 (Security Research Tool)",
            "Accept": "application/json",
        }
        if self.api_key:
            headers["apiKey"] = self.api_key
        
        # Build request URL
        url = f"{self.NVD_API_URL}?cveId={cve_id}"
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(url, headers=headers)
                response.raise_for_status()
                data = response.json()
                return self.parse_nvd_response(data)
        except httpx.HTTPStatusError as e:
            # Return minimal info on HTTP error
            return CVEInfo(
                cve_id=cve_id,
                description=f"NVD API error: HTTP {e.response.status_code}",
            )
        except httpx.RequestError as e:
            # Return minimal info on connection error
            return CVEInfo(
                cve_id=cve_id,
                description=f"NVD API connection error: {str(e)}",
            )
        except Exception as e:
            return CVEInfo(
                cve_id=cve_id,
                description=f"Error fetching CVE: {str(e)}",
            )
    
    def parse_nvd_response(self, data: dict) -> CVEInfo:
        """Parse NVD API response into CVEInfo.
        
        Args:
            data: Raw NVD API response.
            
        Returns:
            Parsed CVEInfo.
        """
        vulnerabilities = data.get("vulnerabilities", [])
        if not vulnerabilities:
            return CVEInfo(cve_id="UNKNOWN", description="CVE not found")
        
        vuln = vulnerabilities[0].get("cve", {})
        
        # Get CVE ID
        cve_id = vuln.get("id", "UNKNOWN")
        
        # Get description (prefer English)
        descriptions = vuln.get("descriptions", [])
        description = ""
        for desc in descriptions:
            if desc.get("lang") == "en":
                description = desc.get("value", "")
                break
        
        # Get CVSS
        cvss = None
        metrics = vuln.get("metrics", {})
        if "cvssMetricV31" in metrics:
            cvss_data = metrics["cvssMetricV31"][0].get("cvssData", {})
            cvss = CVSSScore.from_nvd(cvss_data)
        elif "cvssMetricV30" in metrics:
            cvss_data = metrics["cvssMetricV30"][0].get("cvssData", {})
            cvss = CVSSScore.from_nvd(cvss_data)
        
        # Get references
        references = []
        for ref in vuln.get("references", []):
            references.append(CVEReference(
                url=ref.get("url", ""),
                source=ref.get("source", ""),
                tags=ref.get("tags", []),
            ))
        
        # Get CWE IDs
        cwe_ids = []
        for weakness in vuln.get("weaknesses", []):
            for desc in weakness.get("description", []):
                if desc.get("value", "").startswith("CWE-"):
                    cwe_ids.append(desc["value"])
        
        return CVEInfo(
            cve_id=cve_id,
            description=description,
            cvss=cvss,
            published=vuln.get("published"),
            modified=vuln.get("lastModified"),
            references=references,
            cwe_ids=cwe_ids,
        )
    
    def clear_cache(self) -> None:
        """Clear the CVE cache."""
        self._cache.clear()
