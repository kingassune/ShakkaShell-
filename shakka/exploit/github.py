"""GitHub Proof-of-Concept search for CVE-to-Exploit pipeline.

Searches GitHub for CVE-related exploit repositories and PoCs.
"""

import httpx
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional


class PoCQuality(str, Enum):
    """Quality assessment of PoC code."""
    
    UNKNOWN = "unknown"
    LOW = "low"       # Basic/incomplete PoC
    MEDIUM = "medium" # Working PoC, needs config
    HIGH = "high"     # Well-documented, easy to use


@dataclass
class GitHubPoC:
    """A GitHub repository containing CVE PoC code.
    
    Contains repository metadata and quality assessment.
    """
    
    repo_name: str
    owner: str
    cve_id: Optional[str] = None
    url: str = ""
    description: str = ""
    stars: int = 0
    forks: int = 0
    language: str = ""
    last_updated: str = ""
    quality: PoCQuality = PoCQuality.UNKNOWN
    clone_url: str = ""
    raw_files: list[str] = field(default_factory=list)
    
    def __post_init__(self):
        """Generate URLs if not provided."""
        if not self.url:
            self.url = f"https://github.com/{self.owner}/{self.repo_name}"
        if not self.clone_url:
            self.clone_url = f"https://github.com/{self.owner}/{self.repo_name}.git"
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "repo_name": self.repo_name,
            "owner": self.owner,
            "cve_id": self.cve_id,
            "url": self.url,
            "description": self.description,
            "stars": self.stars,
            "forks": self.forks,
            "language": self.language,
            "last_updated": self.last_updated,
            "quality": self.quality.value,
            "clone_url": self.clone_url,
            "raw_files": self.raw_files,
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> "GitHubPoC":
        """Create from dictionary."""
        return cls(
            repo_name=data.get("repo_name", ""),
            owner=data.get("owner", ""),
            cve_id=data.get("cve_id"),
            description=data.get("description", ""),
            stars=data.get("stars", 0),
            forks=data.get("forks", 0),
            language=data.get("language", ""),
            last_updated=data.get("last_updated", ""),
            quality=PoCQuality(data.get("quality", "unknown")),
            raw_files=data.get("raw_files", []),
        )
    
    @classmethod
    def from_github_api(cls, data: dict) -> "GitHubPoC":
        """Create from GitHub API response.
        
        Args:
            data: GitHub API repository response.
            
        Returns:
            GitHubPoC instance.
        """
        return cls(
            repo_name=data.get("name", ""),
            owner=data.get("owner", {}).get("login", ""),
            url=data.get("html_url", ""),
            description=data.get("description", "") or "",
            stars=data.get("stargazers_count", 0),
            forks=data.get("forks_count", 0),
            language=data.get("language", "") or "",
            last_updated=data.get("updated_at", ""),
            clone_url=data.get("clone_url", ""),
        )
    
    def format(self) -> str:
        """Format PoC for display.
        
        Returns:
            Formatted result string.
        """
        stars_str = f"â­{self.stars}" if self.stars else ""
        return f"[{self.owner}/{self.repo_name}] {stars_str} {self.description[:60]}"
    
    def assess_quality(self) -> PoCQuality:
        """Assess the quality of the PoC based on metadata.
        
        Returns:
            Quality assessment.
        """
        score = 0
        
        # Stars indicate community validation
        if self.stars >= 100:
            score += 3
        elif self.stars >= 20:
            score += 2
        elif self.stars >= 5:
            score += 1
        
        # Description indicates documentation
        if len(self.description) > 50:
            score += 1
        
        # Recent updates indicate maintenance
        if self.last_updated:
            try:
                updated = datetime.fromisoformat(self.last_updated.replace("Z", "+00:00"))
                days_old = (datetime.now(updated.tzinfo) - updated).days
                if days_old < 90:
                    score += 2
                elif days_old < 365:
                    score += 1
            except (ValueError, TypeError):
                pass
        
        # Language indicates code quality
        if self.language in ("Python", "Go", "Rust"):
            score += 1
        
        # Determine quality level
        if score >= 5:
            return PoCQuality.HIGH
        elif score >= 3:
            return PoCQuality.MEDIUM
        elif score >= 1:
            return PoCQuality.LOW
        return PoCQuality.UNKNOWN


class GitHubSearch:
    """GitHub search service for CVE PoCs.
    
    Searches GitHub repositories for CVE proof-of-concept code.
    
    Example:
        search = GitHubSearch()
        results = await search.search_by_cve("CVE-2024-1234")
    """
    
    GITHUB_API = "https://api.github.com"
    
    def __init__(self, token: Optional[str] = None):
        """Initialize the search service.
        
        Args:
            token: Optional GitHub API token for higher rate limits.
        """
        self._token = token
        self._cache: dict[str, list[GitHubPoC]] = {}
    
    @property
    def headers(self) -> dict:
        """Get API request headers."""
        headers = {
            "Accept": "application/vnd.github.v3+json",
            "User-Agent": "ShakkaShell-CVE-Search",
        }
        if self._token:
            headers["Authorization"] = f"token {self._token}"
        return headers
    
    async def search_by_cve(
        self,
        cve_id: str,
        min_stars: int = 0,
        language: Optional[str] = None,
    ) -> list[GitHubPoC]:
        """Search for PoCs by CVE ID.
        
        Args:
            cve_id: CVE identifier to search.
            min_stars: Minimum stars filter.
            language: Optional language filter.
            
        Returns:
            List of matching PoCs sorted by stars.
        """
        cve_id = cve_id.upper().strip()
        cache_key = f"{cve_id}:{min_stars}:{language}"
        
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        results = await self._search_repos(cve_id, min_stars, language)
        
        # Sort by stars (most popular first)
        results.sort(key=lambda x: x.stars, reverse=True)
        
        # Assess quality for each
        for poc in results:
            poc.cve_id = cve_id
            poc.quality = poc.assess_quality()
        
        self._cache[cache_key] = results
        return results
    
    async def search_by_keyword(
        self,
        keyword: str,
        min_stars: int = 0,
        language: Optional[str] = None,
    ) -> list[GitHubPoC]:
        """Search for PoCs by keyword.
        
        Args:
            keyword: Search term.
            min_stars: Minimum stars filter.
            language: Optional language filter.
            
        Returns:
            List of matching PoCs.
        """
        cache_key = f"kw:{keyword}:{min_stars}:{language}"
        
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        results = await self._search_repos(keyword, min_stars, language)
        results.sort(key=lambda x: x.stars, reverse=True)
        
        for poc in results:
            poc.quality = poc.assess_quality()
        
        self._cache[cache_key] = results
        return results
    
    async def _search_repos(
        self,
        query: str,
        min_stars: int = 0,
        language: Optional[str] = None,
    ) -> list[GitHubPoC]:
        """Search GitHub repositories using the Search API.
        
        Args:
            query: Search query.
            min_stars: Minimum stars.
            language: Language filter.
            
        Returns:
            List of PoCs.
        """
        # Build search query
        search_query = f"{query} exploit OR poc OR vulnerability"
        if min_stars > 0:
            search_query += f" stars:>={min_stars}"
        if language:
            search_query += f" language:{language}"
        
        url = f"{self.GITHUB_API}/search/repositories"
        params = {
            "q": search_query,
            "sort": "stars",
            "order": "desc",
            "per_page": 10,
        }
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(url, headers=self.headers, params=params)
                response.raise_for_status()
                data = response.json()
                
                results = []
                for item in data.get("items", []):
                    poc = GitHubPoC.from_github_api(item)
                    results.append(poc)
                
                return results
        except httpx.HTTPStatusError as e:
            # Rate limit or other error - return empty
            if e.response.status_code == 403:
                # Rate limited, return empty
                return []
            return []
        except (httpx.RequestError, Exception):
            return []
    
    async def get_repo_files(self, poc: GitHubPoC) -> list[str]:
        """Get list of files in the repository using GitHub Contents API.
        
        Args:
            poc: GitHub PoC reference.
            
        Returns:
            List of file paths.
        """
        url = f"{self.GITHUB_API}/repos/{poc.owner}/{poc.repo_name}/contents"
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(url, headers=self.headers)
                response.raise_for_status()
                data = response.json()
                
                files = []
                for item in data:
                    if item.get("type") == "file":
                        files.append(item.get("path", ""))
                return files
        except (httpx.HTTPStatusError, httpx.RequestError, Exception):
            return ["README.md", "exploit.py"]  # Fallback

    async def get_file_content(self, poc: GitHubPoC, file_path: str) -> str:
        """Get content of a file from the repository using GitHub Raw API.
        
        Args:
            poc: GitHub PoC reference.
            file_path: Path to file in repo.
            
        Returns:
            File content.
        """
        # Use raw.githubusercontent.com for raw file content
        url = f"https://raw.githubusercontent.com/{poc.owner}/{poc.repo_name}/main/{file_path}"
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(url)
                if response.status_code == 404:
                    # Try master branch
                    url = f"https://raw.githubusercontent.com/{poc.owner}/{poc.repo_name}/master/{file_path}"
                    response = await client.get(url)
                response.raise_for_status()
                return response.text
        except (httpx.HTTPStatusError, httpx.RequestError, Exception):
            return f"# Unable to fetch {file_path}"
    
    def clear_cache(self) -> None:
        """Clear search cache."""
        self._cache.clear()
