"""GitHub Proof-of-Concept search for CVE-to-Exploit pipeline.

Searches GitHub for CVE-related exploit repositories and PoCs.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional


class PoCQuality(str, Enum):
    """Quality assessment of PoC code."""
    
    UNKNOWN = "unknown"
    LOW = "low"       # Basic/incomplete PoC
    MEDIUM = "medium" # Working PoC, needs config
    HIGH = "high"     # Well-documented, easy to use


@dataclass
class GitHubPoC:
    """A GitHub repository containing CVE PoC code.
    
    Contains repository metadata and quality assessment.
    """
    
    repo_name: str
    owner: str
    cve_id: Optional[str] = None
    url: str = ""
    description: str = ""
    stars: int = 0
    forks: int = 0
    language: str = ""
    last_updated: str = ""
    quality: PoCQuality = PoCQuality.UNKNOWN
    clone_url: str = ""
    raw_files: list[str] = field(default_factory=list)
    
    def __post_init__(self):
        """Generate URLs if not provided."""
        if not self.url:
            self.url = f"https://github.com/{self.owner}/{self.repo_name}"
        if not self.clone_url:
            self.clone_url = f"https://github.com/{self.owner}/{self.repo_name}.git"
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "repo_name": self.repo_name,
            "owner": self.owner,
            "cve_id": self.cve_id,
            "url": self.url,
            "description": self.description,
            "stars": self.stars,
            "forks": self.forks,
            "language": self.language,
            "last_updated": self.last_updated,
            "quality": self.quality.value,
            "clone_url": self.clone_url,
            "raw_files": self.raw_files,
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> "GitHubPoC":
        """Create from dictionary."""
        return cls(
            repo_name=data.get("repo_name", ""),
            owner=data.get("owner", ""),
            cve_id=data.get("cve_id"),
            description=data.get("description", ""),
            stars=data.get("stars", 0),
            forks=data.get("forks", 0),
            language=data.get("language", ""),
            last_updated=data.get("last_updated", ""),
            quality=PoCQuality(data.get("quality", "unknown")),
            raw_files=data.get("raw_files", []),
        )
    
    @classmethod
    def from_github_api(cls, data: dict) -> "GitHubPoC":
        """Create from GitHub API response.
        
        Args:
            data: GitHub API repository response.
            
        Returns:
            GitHubPoC instance.
        """
        return cls(
            repo_name=data.get("name", ""),
            owner=data.get("owner", {}).get("login", ""),
            url=data.get("html_url", ""),
            description=data.get("description", "") or "",
            stars=data.get("stargazers_count", 0),
            forks=data.get("forks_count", 0),
            language=data.get("language", "") or "",
            last_updated=data.get("updated_at", ""),
            clone_url=data.get("clone_url", ""),
        )
    
    def format(self) -> str:
        """Format PoC for display.
        
        Returns:
            Formatted result string.
        """
        stars_str = f"â­{self.stars}" if self.stars else ""
        return f"[{self.owner}/{self.repo_name}] {stars_str} {self.description[:60]}"
    
    def assess_quality(self) -> PoCQuality:
        """Assess the quality of the PoC based on metadata.
        
        Returns:
            Quality assessment.
        """
        score = 0
        
        # Stars indicate community validation
        if self.stars >= 100:
            score += 3
        elif self.stars >= 20:
            score += 2
        elif self.stars >= 5:
            score += 1
        
        # Description indicates documentation
        if len(self.description) > 50:
            score += 1
        
        # Recent updates indicate maintenance
        if self.last_updated:
            try:
                updated = datetime.fromisoformat(self.last_updated.replace("Z", "+00:00"))
                days_old = (datetime.now(updated.tzinfo) - updated).days
                if days_old < 90:
                    score += 2
                elif days_old < 365:
                    score += 1
            except (ValueError, TypeError):
                pass
        
        # Language indicates code quality
        if self.language in ("Python", "Go", "Rust"):
            score += 1
        
        # Determine quality level
        if score >= 5:
            return PoCQuality.HIGH
        elif score >= 3:
            return PoCQuality.MEDIUM
        elif score >= 1:
            return PoCQuality.LOW
        return PoCQuality.UNKNOWN


class GitHubSearch:
    """GitHub search service for CVE PoCs.
    
    Searches GitHub repositories for CVE proof-of-concept code.
    
    Example:
        search = GitHubSearch()
        results = await search.search_by_cve("CVE-2024-1234")
    """
    
    GITHUB_API = "https://api.github.com"
    
    def __init__(self, token: Optional[str] = None):
        """Initialize the search service.
        
        Args:
            token: Optional GitHub API token for higher rate limits.
        """
        self._token = token
        self._cache: dict[str, list[GitHubPoC]] = {}
    
    @property
    def headers(self) -> dict:
        """Get API request headers."""
        headers = {
            "Accept": "application/vnd.github.v3+json",
            "User-Agent": "ShakkaShell-CVE-Search",
        }
        if self._token:
            headers["Authorization"] = f"token {self._token}"
        return headers
    
    async def search_by_cve(
        self,
        cve_id: str,
        min_stars: int = 0,
        language: Optional[str] = None,
    ) -> list[GitHubPoC]:
        """Search for PoCs by CVE ID.
        
        Args:
            cve_id: CVE identifier to search.
            min_stars: Minimum stars filter.
            language: Optional language filter.
            
        Returns:
            List of matching PoCs sorted by stars.
        """
        cve_id = cve_id.upper().strip()
        cache_key = f"{cve_id}:{min_stars}:{language}"
        
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        results = await self._search_repos(cve_id, min_stars, language)
        
        # Sort by stars (most popular first)
        results.sort(key=lambda x: x.stars, reverse=True)
        
        # Assess quality for each
        for poc in results:
            poc.cve_id = cve_id
            poc.quality = poc.assess_quality()
        
        self._cache[cache_key] = results
        return results
    
    async def search_by_keyword(
        self,
        keyword: str,
        min_stars: int = 0,
        language: Optional[str] = None,
    ) -> list[GitHubPoC]:
        """Search for PoCs by keyword.
        
        Args:
            keyword: Search term.
            min_stars: Minimum stars filter.
            language: Optional language filter.
            
        Returns:
            List of matching PoCs.
        """
        cache_key = f"kw:{keyword}:{min_stars}:{language}"
        
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        results = await self._search_repos(keyword, min_stars, language)
        results.sort(key=lambda x: x.stars, reverse=True)
        
        for poc in results:
            poc.quality = poc.assess_quality()
        
        self._cache[cache_key] = results
        return results
    
    async def _search_repos(
        self,
        query: str,
        min_stars: int = 0,
        language: Optional[str] = None,
    ) -> list[GitHubPoC]:
        """Search GitHub repositories.
        
        In production, calls GitHub API.
        For testing, returns simulated results.
        
        Args:
            query: Search query.
            min_stars: Minimum stars.
            language: Language filter.
            
        Returns:
            List of PoCs.
        """
        # Simulated results for testing
        # In production: use GitHub Search API
        
        # Build simulated result
        year = datetime.now().year
        return [
            GitHubPoC(
                repo_name=f"{query.lower().replace(' ', '-')}-poc",
                owner="security-researcher",
                cve_id=query if query.upper().startswith("CVE-") else None,
                description=f"Proof of concept exploit for {query}",
                stars=25,
                forks=5,
                language=language or "Python",
                last_updated=datetime.now().isoformat(),
            ),
            GitHubPoC(
                repo_name=f"{query.lower().replace(' ', '-')}-scanner",
                owner="vuln-researcher",
                cve_id=query if query.upper().startswith("CVE-") else None,
                description=f"Vulnerability scanner for {query}",
                stars=12,
                forks=2,
                language="Go",
                last_updated=datetime.now().isoformat(),
            ),
        ]
    
    async def get_repo_files(self, poc: GitHubPoC) -> list[str]:
        """Get list of files in the repository.
        
        Args:
            poc: GitHub PoC reference.
            
        Returns:
            List of file paths.
        """
        # In production: use GitHub Contents API
        # For testing: return simulated file list
        return [
            "README.md",
            "exploit.py",
            "requirements.txt",
        ]
    
    async def get_file_content(self, poc: GitHubPoC, file_path: str) -> str:
        """Get content of a file from the repository.
        
        Args:
            poc: GitHub PoC reference.
            file_path: Path to file in repo.
            
        Returns:
            File content.
        """
        # In production: use GitHub Raw API
        # For testing: return placeholder
        if file_path == "exploit.py":
            return f"""#!/usr/bin/env python3
# PoC for {poc.cve_id or 'vulnerability'}
# Repository: {poc.url}

import sys

def main():
    print("Proof of concept exploit")
    # Implementation here
    pass

if __name__ == "__main__":
    main()
"""
        elif file_path == "README.md":
            return f"# {poc.repo_name}\n\n{poc.description}\n"
        else:
            return ""
    
    def clear_cache(self) -> None:
        """Clear search cache."""
        self._cache.clear()
